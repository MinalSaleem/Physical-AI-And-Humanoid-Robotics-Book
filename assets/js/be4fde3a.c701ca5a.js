"use strict";(globalThis.webpackChunkbook=globalThis.webpackChunkbook||[]).push([[1231],{7683:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"module-two/02-gazebo-physics-collisions","title":"Simulating Physics, Gravity, and Collisions in Gazebo","description":"Realistic physics simulation is fundamental to the digital twin concept. It allows engineers and researchers to test robot designs, control algorithms, and interaction with the environment in a virtual space that closely mimics the real world. Gazebo excels in this area, offering robust physics engines and extensive configuration options. For more advanced visualization and human-robot interaction, see Chapter 3 Simulating Sensors: LiDAR, Depth Cameras, and IMUs.","source":"@site/docs/02-module-two/02-gazebo-physics-collisions.md","sourceDirName":"02-module-two","slug":"/module-two/02-gazebo-physics-collisions","permalink":"/Physical-AI-And-Humanoid-Robotics-Book/docs/module-two/02-gazebo-physics-collisions","draft":false,"unlisted":false,"editUrl":"https://github.com/MinalSaleem/Physical-AI-And-Humanoid-Robotics-Book/tree/main/book/docs/02-module-two/02-gazebo-physics-collisions.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"id":"02-gazebo-physics-collisions","title":"Simulating Physics, Gravity, and Collisions in Gazebo","sidebar_label":"Chapter 2: Gazebo Physics","sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 1: Physics Sim & Env","permalink":"/Physical-AI-And-Humanoid-Robotics-Book/docs/module-two/01-physics-sim-env-building"},"next":{"title":"Chapter 3: Unity Rendering & HRI","permalink":"/Physical-AI-And-Humanoid-Robotics-Book/docs/module-two/03-unity-rendering-hri"}}');var o=n(4848),t=n(8453);const a={id:"02-gazebo-physics-collisions",title:"Simulating Physics, Gravity, and Collisions in Gazebo",sidebar_label:"Chapter 2: Gazebo Physics",sidebar_position:2},r="Simulating Physics, Gravity, and Collisions in Gazebo",c={},l=[{value:"2.1. Gazebo Physics Engines",id:"21-gazebo-physics-engines",level:2},{value:"2.2. Setting Gravity",id:"22-setting-gravity",level:2},{value:"2.3. Defining Link Mass and Inertia",id:"23-defining-link-mass-and-inertia",level:2},{value:"2.4. Collision Geometries and Contact Sensors",id:"24-collision-geometries-and-contact-sensors",level:2},{value:"Contact Sensors",id:"contact-sensors",level:3},{value:"Summary",id:"summary",level:2},{value:"Further Reading",id:"further-reading",level:2}];function d(e){const i={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(i.header,{children:(0,o.jsx)(i.h1,{id:"simulating-physics-gravity-and-collisions-in-gazebo",children:"Simulating Physics, Gravity, and Collisions in Gazebo"})}),"\n",(0,o.jsxs)(i.p,{children:["Realistic physics simulation is fundamental to the digital twin concept. It allows engineers and researchers to test robot designs, control algorithms, and interaction with the environment in a virtual space that closely mimics the real world. Gazebo excels in this area, offering robust physics engines and extensive configuration options. For more advanced visualization and human-robot interaction, see ",(0,o.jsx)(i.a,{href:"/Physical-AI-And-Humanoid-Robotics-Book/docs/module-two/03-unity-rendering-hri",children:"Chapter 3: High-Fidelity Rendering and Human-Robot Interaction in Unity"}),". To integrate and simulate various sensors in these digital twin environments, refer to ",(0,o.jsx)(i.a,{href:"/Physical-AI-And-Humanoid-Robotics-Book/docs/module-two/04-simulating-sensors",children:"Chapter 4: Simulating Sensors: LiDAR, Depth Cameras, and IMUs"}),"."]}),"\n",(0,o.jsx)(i.h2,{id:"21-gazebo-physics-engines",children:"2.1. Gazebo Physics Engines"}),"\n",(0,o.jsx)(i.p,{children:"Gazebo doesn't implement its own physics engine from scratch. Instead, it acts as a wrapper around several high-performance, open-source physics libraries. You can choose the engine that best suits your simulation needs, based on factors like stability, speed, and feature set. Common options include:"}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"ODE (Open Dynamics Engine)"}),": The default engine in Gazebo, known for its speed and ability to handle rigid body dynamics with contacts."]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Bullet"}),": A popular open-source physics engine used in many games and simulations. Offers good performance and features."]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Simbody"}),": Designed for high-performance simulation of biological and biomechanical systems."]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"DART (Dynamic Animation and Robotics Toolkit)"}),": Optimized for robotics and biomechanics research, providing advanced capabilities for contact and collision handling."]}),"\n"]}),"\n",(0,o.jsxs)(i.p,{children:["The choice of physics engine is typically specified in your ",(0,o.jsx)(i.code,{children:".world"})," file within the ",(0,o.jsx)(i.code,{children:"<physics>"})," tag."]}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-xml",children:'<physics name="default_physics" default="true" type="ode">\n  <max_step_size>0.001</max_step_size>\n  <real_time_factor>1.0</real_time_factor>\n  <real_time_update_rate>1000</real_time_update_rate>\n  <ode>\n    <solver>\n      <type>quick</type>\n      <iters>50</iters>\n      <sor>1.3</sor>\n      <min_depth>0.001</min_depth>\n    </solver>\n    <constraints>\n      <cfm>0.0</cfm>\n      <erp>0.2</erp>\n      <contact_max_correcting_vel>100.0</contact_max_correcting_vel>\n      <contact_surface_layer>0.001</contact_surface_layer>\n    </constraints>\n  </ode>\n</physics>\n'})}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:(0,o.jsx)(i.code,{children:"max_step_size"})}),": The maximum time step allowed for the physics simulation. Smaller values lead to more accurate but slower simulations."]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:(0,o.jsx)(i.code,{children:"real_time_factor"})}),": The ratio of simulated time to real time. ",(0,o.jsx)(i.code,{children:"1.0"})," means the simulation runs at real-time speed. Values greater than ",(0,o.jsx)(i.code,{children:"1.0"})," mean faster-than-real-time."]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:(0,o.jsx)(i.code,{children:"real_time_update_rate"})}),": The frequency at which the physics engine is updated."]}),"\n"]}),"\n",(0,o.jsx)(i.h2,{id:"22-setting-gravity",children:"2.2. Setting Gravity"}),"\n",(0,o.jsxs)(i.p,{children:["Gravity is a fundamental force in any realistic physics simulation. In Gazebo, gravity is defined in the ",(0,o.jsx)(i.code,{children:"<world>"})," tag of your ",(0,o.jsx)(i.code,{children:".world"})," file."]}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-xml",children:"<gravity>0 0 -9.8</gravity> \x3c!-- x y z components of gravity vector --\x3e\n"})}),"\n",(0,o.jsxs)(i.p,{children:["The default value ",(0,o.jsx)(i.code,{children:"-9.8"})," in the z-direction simulates Earth's gravity. You can change these values to simulate different gravitational environments or even zero gravity."]}),"\n",(0,o.jsx)(i.h2,{id:"23-defining-link-mass-and-inertia",children:"2.3. Defining Link Mass and Inertia"}),"\n",(0,o.jsxs)(i.p,{children:["For objects to interact realistically with physics, they must have defined mass and inertial properties. These are specified within the ",(0,o.jsx)(i.code,{children:"<inertial>"})," tag of a ",(0,o.jsx)(i.code,{children:"<link>"})," in your robot's SDF/URDF model."]}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:(0,o.jsx)(i.code,{children:"mass"})}),": The total mass of the link in kilograms."]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:(0,o.jsx)(i.code,{children:"inertia"})}),": A 3x3 inertia tensor matrix (represented by ",(0,o.jsx)(i.code,{children:"ixx"}),", ",(0,o.jsx)(i.code,{children:"iyy"}),", ",(0,o.jsx)(i.code,{children:"izz"}),", ",(0,o.jsx)(i.code,{children:"ixy"}),", ",(0,o.jsx)(i.code,{children:"ixz"}),", ",(0,o.jsx)(i.code,{children:"iyz"}),") that describes how difficult it is to change the rotational motion of the link. It's crucial for realistic rotational dynamics. For simple geometric shapes, you can often find formulas to calculate these values."]}),"\n"]}),"\n",(0,o.jsxs)(i.p,{children:["Example from Chapter 1's ",(0,o.jsx)(i.code,{children:"cube_world.world"})," model:"]}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-xml",children:"        <inertial>\n          <mass>1.0</mass>\n          <inertia>\n            <ixx>0.00666</ixx> <iyy>0.00666</iyy> <izz>0.00666</izz>\n            <ixy>0.0</ixy> <ixz>0.0</ixz> <iyz>0.0</iyz>\n          </inertia>\n        </inertial>\n"})}),"\n",(0,o.jsx)(i.h2,{id:"24-collision-geometries-and-contact-sensors",children:"2.4. Collision Geometries and Contact Sensors"}),"\n",(0,o.jsxs)(i.p,{children:["Collision detection is the process by which a physics engine determines if two objects are in contact or interpenetrating. In Gazebo, collision properties are defined in the ",(0,o.jsx)(i.code,{children:"<collision>"})," tag within a ",(0,o.jsx)(i.code,{children:"<link>"}),"."]}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:(0,o.jsx)(i.code,{children:"geometry"})}),": Defines the shape of the collision body (e.g., ",(0,o.jsx)(i.code,{children:"box"}),", ",(0,o.jsx)(i.code,{children:"sphere"}),", ",(0,o.jsx)(i.code,{children:"cylinder"}),", ",(0,o.jsx)(i.code,{children:"mesh"}),"). It's often a simplified version of the ",(0,o.jsx)(i.code,{children:"<visual>"})," geometry to reduce computational load."]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:(0,o.jsx)(i.code,{children:"surface"})}),": (Optional) Specifies physical properties of the surface like friction, restitution (bounciness), and contact parameters."]}),"\n"]}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-xml",children:'<collision name="my_collision_body">\n    <geometry>\n        <box>\n            <size>0.2 0.2 0.2</size>\n        </box>\n    </geometry>\n    <surface>\n        <friction>\n            <ode>\n                <mu>0.9</mu> \x3c!-- Coefficient of friction --\x3e\n                <mu2>0.9</mu2>\n            </ode>\n        </friction>\n        <bounce>\n            <restitution_coefficient>0.1</restitution_coefficient> \x3c!-- Bounciness --\x3e\n            <threshold>0.05</threshold>\n        </bounce>\n    </surface>\n</collision>\n'})}),"\n",(0,o.jsx)(i.h3,{id:"contact-sensors",children:"Contact Sensors"}),"\n",(0,o.jsxs)(i.p,{children:["To detect collisions programmatically within your robot's software, you can attach a ",(0,o.jsx)(i.strong,{children:"contact sensor"})," to a link. A contact sensor will report when specific parts of your robot (or other objects in the world) are touching."]}),"\n",(0,o.jsx)(i.p,{children:"Contact sensor definition in SDF:"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-xml",children:'<sensor name="my_contact_sensor" type="contact">\n  <always_on>1</always_on>\n  <update_rate>100</update_rate>\n  <contact>\n    <collision>my_link::my_collision_body</collision>\n  </contact>\n  <plugin name="gazebo_ros_bumper" filename="libgazebo_ros_bumper.so">\n    <ros>\n      <namespace>/my_robot</namespace>\n      <argument>~/out:=contact_sensor_data</argument>\n    </ros>\n    <always_on>true</always_on>\n    <update_rate>100</update_rate>\n    <bumperTopicName>contact_sensor_data</bumperTopicName>\n  </plugin>\n</sensor>\n'})}),"\n",(0,o.jsxs)(i.p,{children:["This sensor will publish contact information to the ",(0,o.jsx)(i.code,{children:"/my_robot/contact_sensor_data"})," ROS 2 topic if ",(0,o.jsx)(i.code,{children:"libgazebo_ros_bumper.so"})," is used."]}),"\n",(0,o.jsx)(i.h2,{id:"summary",children:"Summary"}),"\n",(0,o.jsxs)(i.p,{children:["Accurate physics simulation, including gravity and collision handling, is critical for developing robust robotic systems. Gazebo provides powerful tools to define and configure these aspects through its choice of physics engines, ",(0,o.jsx)(i.code,{children:".world"})," file configurations for gravity, and detailed ",(0,o.jsx)(i.code,{children:"<inertial>"})," and ",(0,o.jsx)(i.code,{children:"<collision>"})," properties within robot models. Understanding these elements allows you to create highly realistic virtual testbeds for your AI-native robots."]}),"\n",(0,o.jsx)(i.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsx)(i.li,{children:(0,o.jsx)(i.a,{href:"http://gazebosim.org/tutorials?tut=physics_params&cat=physics",children:"Gazebo Physics Tutorial"})}),"\n",(0,o.jsx)(i.li,{children:(0,o.jsx)(i.a,{href:"http://sdformat.org/spec?ver=1.7&elem=link",children:"SDF Specification: Link"})}),"\n",(0,o.jsx)(i.li,{children:(0,o.jsx)(i.a,{href:"http://sdformat.org/spec?ver=1.7&elem=sensor",children:"SDF Specification: Sensor"})}),"\n",(0,o.jsx)(i.li,{children:(0,o.jsx)(i.a,{href:"https://github.com/ros-simulation/gazebo_ros_pkgs/wiki",children:"ROS 2 Gazebo Plugins"})}),"\n"]})]})}function h(e={}){const{wrapper:i}={...(0,t.R)(),...e.components};return i?(0,o.jsx)(i,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,i,n)=>{n.d(i,{R:()=>a,x:()=>r});var s=n(6540);const o={},t=s.createContext(o);function a(e){const i=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function r(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),s.createElement(t.Provider,{value:i},e.children)}}}]);
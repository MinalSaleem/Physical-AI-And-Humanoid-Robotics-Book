"use strict";(globalThis.webpackChunkbook=globalThis.webpackChunkbook||[]).push([[8151],{246:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"module-one/03-python-rclpy-integration","title":"Bridging Python Agents to ROS Controllers using rclpy","description":"In the realm of AI-native robotics, Python is often the language of choice for developing intelligent agents due to its rich ecosystem of AI/ML libraries. To enable these Python agents to interact with ROS 2-powered robots, we use rclpy, the official Python client library for ROS 2. rclpy allows Python programs to create ROS 2 nodes, publish and subscribe to topics, call and provide services, and interact with parameters and actions. This enables seamless control of robotic systems, including complex humanoid robots, whose physical structure is often defined using URDF, as we will explore in Chapter 4: Understanding URDF (Unified Robot Description Format) for Humanoids.","source":"@site/docs/01-module-one/03-python-rclpy-integration.md","sourceDirName":"01-module-one","slug":"/module-one/03-python-rclpy-integration","permalink":"/Physical-AI-And-Humanoid-Robotics-Book/docs/module-one/03-python-rclpy-integration","draft":false,"unlisted":false,"editUrl":"https://github.com/MinalSaleem/Physical-AI-And-Humanoid-Robotics-Book/tree/main/book/docs/01-module-one/03-python-rclpy-integration.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"id":"03-python-rclpy-integration","title":"Bridging Python Agents to ROS Controllers using rclpy","sidebar_label":"Chapter 3: Python rclpy","sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 2: Nodes, Topics, Services","permalink":"/Physical-AI-And-Humanoid-Robotics-Book/docs/module-one/02-nodes-topics-services"},"next":{"title":"Chapter 4: URDF for Humanoids","permalink":"/Physical-AI-And-Humanoid-Robotics-Book/docs/module-one/04-urdf-humanoids"}}');var r=i(4848),t=i(8453);const o={id:"03-python-rclpy-integration",title:"Bridging Python Agents to ROS Controllers using rclpy",sidebar_label:"Chapter 3: Python rclpy",sidebar_position:3},l="Bridging Python Agents to ROS Controllers using rclpy",a={},c=[{value:"3.1. <code>rclpy</code> Overview and Setup",id:"31-rclpy-overview-and-setup",level:2},{value:"Setup",id:"setup",level:3},{value:"3.2. Creating a Simple Publisher Node in Python",id:"32-creating-a-simple-publisher-node-in-python",level:2},{value:"3.3. Creating a Simple Subscriber Node in Python",id:"33-creating-a-simple-subscriber-node-in-python",level:2},{value:"3.4. Implementing a Basic Service Client and Server in Python",id:"34-implementing-a-basic-service-client-and-server-in-python",level:2},{value:"3.5. Error Handling and Best Practices in <code>rclpy</code>",id:"35-error-handling-and-best-practices-in-rclpy",level:2},{value:"Summary",id:"summary",level:2},{value:"Further Reading",id:"further-reading",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"bridging-python-agents-to-ros-controllers-using-rclpy",children:"Bridging Python Agents to ROS Controllers using rclpy"})}),"\n",(0,r.jsxs)(n.p,{children:["In the realm of AI-native robotics, Python is often the language of choice for developing intelligent agents due to its rich ecosystem of AI/ML libraries. To enable these Python agents to interact with ROS 2-powered robots, we use ",(0,r.jsx)(n.code,{children:"rclpy"}),", the official Python client library for ROS 2. ",(0,r.jsx)(n.code,{children:"rclpy"})," allows Python programs to create ROS 2 nodes, publish and subscribe to topics, call and provide services, and interact with parameters and actions. This enables seamless control of robotic systems, including complex humanoid robots, whose physical structure is often defined using URDF, as we will explore in ",(0,r.jsx)(n.a,{href:"/Physical-AI-And-Humanoid-Robotics-Book/docs/module-one/04-urdf-humanoids",children:"Chapter 4: Understanding URDF (Unified Robot Description Format) for Humanoids"}),"."]}),"\n",(0,r.jsxs)(n.h2,{id:"31-rclpy-overview-and-setup",children:["3.1. ",(0,r.jsx)(n.code,{children:"rclpy"})," Overview and Setup"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"rclpy"})," is designed to be idiomatic Python, providing a straightforward API for ROS 2 communication. It builds upon ",(0,r.jsx)(n.code,{children:"rcl"})," (ROS Client Library), which is a C API that provides the common functionality for all client libraries."]}),"\n",(0,r.jsx)(n.h3,{id:"setup",children:"Setup"}),"\n",(0,r.jsxs)(n.p,{children:["Before you can use ",(0,r.jsx)(n.code,{children:"rclpy"}),", you need to have ROS 2 installed and sourced in your environment. Assuming you have ROS 2 (e.g., Humble Hawksbill) installed, you typically don't need to install ",(0,r.jsx)(n.code,{children:"rclpy"})," separately as it comes with the ROS 2 Python development tools."]}),"\n",(0,r.jsxs)(n.p,{children:["To use ",(0,r.jsx)(n.code,{children:"rclpy"})," within your Python projects, ensure your ROS 2 environment is sourced:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# For Linux/macOS\nsource /opt/ros/humble/setup.bash\n\n# For Windows (PowerShell)\n# .\\install\\setup.ps1\n"})}),"\n",(0,r.jsxs)(n.p,{children:["You can then import ",(0,r.jsx)(n.code,{children:"rclpy"})," in your Python scripts:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\n# Other imports like message types (e.g., from std_msgs.msg import String)\n"})}),"\n",(0,r.jsx)(n.h2,{id:"32-creating-a-simple-publisher-node-in-python",children:"3.2. Creating a Simple Publisher Node in Python"}),"\n",(0,r.jsxs)(n.p,{children:["A publisher node sends messages to a topic. Here's how to create a basic ROS 2 publisher in Python using ",(0,r.jsx)(n.code,{children:"rclpy"}),'. This node will publish a simple "Hello ROS 2" string to the ',(0,r.jsx)(n.code,{children:"/topic"})," topic every 0.5 seconds."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"minimal_publisher.py"})}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String # Import the String message type\n\nclass MinimalPublisher(Node):\n    def __init__(self):\n        # Initialize the node with the name 'minimal_publisher'\n        super().__init__('minimal_publisher')\n        # Create a publisher for the 'topic' topic, using String messages, with a queue size of 10\n        self.publisher_ = self.create_publisher(String, 'topic', 10)\n        timer_period = 0.5  # seconds\n        # Create a timer that calls the timer_callback method every 0.5 seconds\n        self.timer = self.create_timer(timer_period, self.timer_callback)\n        self.i = 0 # Counter for messages\n\n    def timer_callback(self):\n        # Create a new String message\n        msg = String()\n        msg.data = 'Hello ROS 2: %d' % self.i # Set the message data\n        self.publisher_.publish(msg) # Publish the message\n        self.get_logger().info('Publishing: \"%s\"' % msg.data) # Log the published message\n        self.i += 1 # Increment counter\n\ndef main(args=None):\n    rclpy.init(args=args) # Initialize rclpy\n    minimal_publisher = MinimalPublisher() # Create the publisher node\n    rclpy.spin(minimal_publisher) # Keep the node alive until Ctrl+C is pressed\n    # Destroy the node and shutdown rclpy when done\n    minimal_publisher.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,r.jsxs)(n.p,{children:["To run this node, save it as ",(0,r.jsx)(n.code,{children:"minimal_publisher.py"})," and then execute:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"python3 minimal_publisher.py\n"})}),"\n",(0,r.jsx)(n.h2,{id:"33-creating-a-simple-subscriber-node-in-python",children:"3.3. Creating a Simple Subscriber Node in Python"}),"\n",(0,r.jsxs)(n.p,{children:["A subscriber node receives messages from a topic. This node will listen to the ",(0,r.jsx)(n.code,{children:"/topic"})," topic and print any incoming string messages."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"minimal_subscriber.py"})}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String # Import the String message type\n\nclass MinimalSubscriber(Node):\n    def __init__(self):\n        # Initialize the node with the name 'minimal_subscriber'\n        super().__init__('minimal_subscriber')\n        # Create a subscription to the 'topic' topic, using String messages\n        # The 'listener_callback' method will be called when a message is received\n        self.subscription = self.create_subscription(\n            String,\n            'topic',\n            self.listener_callback,\n            10) # Queue size of 10\n        self.subscription  # prevent unused variable warning\n\n    def listener_callback(self, msg):\n        # Log the received message\n        self.get_logger().info('I heard: \"%s\"' % msg.data)\n\ndef main(args=None):\n    rclpy.init(args=args) # Initialize rclpy\n    minimal_subscriber = MinimalSubscriber() # Create the subscriber node\n    rclpy.spin(minimal_subscriber) # Keep the node alive until Ctrl+C is pressed\n    # Destroy the node and shutdown rclpy when done\n    minimal_subscriber.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,r.jsxs)(n.p,{children:["To run this node, save it as ",(0,r.jsx)(n.code,{children:"minimal_subscriber.py"})," and then execute:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"python3 minimal_subscriber.py\n"})}),"\n",(0,r.jsx)(n.p,{children:"Run the publisher and subscriber simultaneously in two different terminals to observe the communication."}),"\n",(0,r.jsx)(n.h2,{id:"34-implementing-a-basic-service-client-and-server-in-python",children:"3.4. Implementing a Basic Service Client and Server in Python"}),"\n",(0,r.jsx)(n.p,{children:"Services allow for synchronous request-response communication. Here, we'll demonstrate a simple service server that adds two integers and a client that requests this operation."}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsxs)(n.strong,{children:[(0,r.jsx)(n.code,{children:"minimal_service.py"})," (Service Server)"]}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"from example_interfaces.srv import AddTwoInts # Import the service type\nimport rclpy\nfrom rclpy.node import Node\n\nclass MinimalService(Node):\n    def __init__(self):\n        # Initialize the node with the name 'minimal_service'\n        super().__init__('minimal_service')\n        # Create a service named 'add_two_ints' using the AddTwoInts service type\n        # The 'add_two_ints_callback' method will handle incoming requests\n        self.srv = self.create_service(AddTwoInts, 'add_two_ints', self.add_two_ints_callback)\n        self.get_logger().info('Service server started.')\n\n    def add_two_ints_callback(self, request, response):\n        # Perform the addition and set the response sum\n        response.sum = request.a + request.b\n        self.get_logger().info('Incoming request: a: %d b: %d' % (request.a, request.b))\n        return response # Return the response\n\ndef main(args=None):\n    rclpy.init(args=args) # Initialize rclpy\n    minimal_service = MinimalService() # Create the service node\n    rclpy.spin(minimal_service) # Keep the node alive\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsxs)(n.strong,{children:[(0,r.jsx)(n.code,{children:"minimal_client.py"})," (Service Client)"]}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"import sys\nfrom example_interfaces.srv import AddTwoInts # Import the service type\nimport rclpy\nfrom rclpy.node import Node\n\nclass MinimalClientAsync(Node):\n    def __init__(self):\n        # Initialize the node with the name 'minimal_client_async'\n        super().__init__('minimal_client_async')\n        # Create a client for the 'add_two_ints' service\n        self.cli = self.create_client(AddTwoInts, 'add_two_ints')\n        # Wait for the service to be available\n        while not self.cli.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info('Service not available, waiting again...')\n        self.req = AddTwoInts.Request() # Create a request object\n\n    def send_request(self):\n        # Set the request arguments from command line\n        self.req.a = int(sys.argv[1])\n        self.req.b = int(sys.argv[2])\n        # Call the service asynchronously\n        self.future = self.cli.call_async(self.req)\n        # Wait until the future is complete (response received)\n        rclpy.spin_until_future_complete(self, self.future)\n        return self.future.result() # Return the result\n\ndef main(args=None):\n    rclpy.init(args=args) # Initialize rclpy\n    minimal_client = MinimalClientAsync() # Create the client node\n    response = minimal_client.send_request() # Send request and get response\n    minimal_client.get_logger().info(\n        'Result of add_two_ints: for %d + %d = %d' %\n        (minimal_client.req.a, minimal_client.req.b, response.sum)) # Log the result\n    minimal_client.destroy_node() # Destroy the node\n    rclpy.shutdown() # Shutdown rclpy\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,r.jsx)(n.p,{children:"To run these:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["In one terminal, start the service server: ",(0,r.jsx)(n.code,{children:"python3 minimal_service.py"})]}),"\n",(0,r.jsxs)(n.li,{children:["In another terminal, call the client with arguments: ",(0,r.jsx)(n.code,{children:"python3 minimal_client.py 5 7"})," (this will add 5 and 7)."]}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"35-error-handling-and-best-practices-in-rclpy",children:["3.5. Error Handling and Best Practices in ",(0,r.jsx)(n.code,{children:"rclpy"})]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Node Initialization and Shutdown"}),": Always ensure ",(0,r.jsx)(n.code,{children:"rclpy.init()"})," and ",(0,r.jsx)(n.code,{children:"rclpy.shutdown()"})," are called. Nodes should be destroyed using ",(0,r.jsx)(n.code,{children:"node.destroy_node()"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Logging"}),": Use ",(0,r.jsx)(n.code,{children:"self.get_logger().info()"}),", ",(0,r.jsx)(n.code,{children:"warn()"}),", ",(0,r.jsx)(n.code,{children:"error()"}),", etc., for proper ROS 2 logging."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Parameter Handling"}),": Utilize ROS 2 parameters for configurable node behaviors rather than hardcoding values."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Message Definition"}),": Prefer existing ROS 2 message types when possible. Define custom messages only when necessary."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"QoS Profiles"}),": Carefully select QoS profiles for publishers and subscribers based on your application's requirements for reliability, latency, and throughput."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Asynchronous Operations"}),": For long-running tasks, consider using ",(0,r.jsx)(n.code,{children:"Actions"})," instead of ",(0,r.jsx)(n.code,{children:"Services"})," to provide periodic feedback and allow for cancellation."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"rclpy"})," provides a powerful and intuitive Python interface for interacting with ROS 2. By mastering the creation of nodes, publishers, subscribers, and service clients/servers, you can effectively bridge your Python AI agents with the underlying robot control infrastructure, enabling sophisticated autonomous behaviors. Adhering to best practices in error handling and resource management will ensure the robustness of your robot applications."]}),"\n",(0,r.jsx)(n.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://docs.ros.org/en/humble/p/rclpy/index.html",children:"rclpy documentation"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://docs.ros.org/en/humble/Tutorials/Beginner-CLI-Tools/Writing-A-Simple-Publisher-And-Subscriber--Python.html",children:"ROS 2 Tutorials: Writing a simple publisher and subscriber (Python)"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://docs.ros.org/en/humble/Tutorials/Beginner-CLI-Tools/Writing-A-Simple-Service-And-Client--Python.html",children:"ROS 2 Tutorials: Writing a simple service and client (Python)"})}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>l});var s=i(6540);const r={},t=s.createContext(r);function o(e){const n=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);